# Java面试总结

## 如何实现字符串的反转

- 运用java字符串

```java
public static String reverse(String s){
    int len=s.length();
    String str="";
    for (int i = 0; i < len; i++)
    {
        //charAt()返回指定索引处的 char 值。索引范围为从 0 到 length() - 1
        //序列的第一个 char 值在索引 0 处，第二个在索引 1 处，依此类推
        str=s.charAt(i)+str;
    }
    return str;
}
```

- 运用递归方式

```java
public static String resverse1(String originStr)
{
    if (originStr ==null || originStr.length()<=1) return originStr;
    return reverse(originStr.substring(1))+originStr.charAt(0);
}
```

- 运用StringBuffer中的Resverse方法

```java
public static String resverse2(String s){
    String str;
    StringBuffer sbBuffer =new StringBuffer(s);
    str=sbBuffer.reverse().toString();
    return str;
}
```

具体调用：

```java
@Test
public void m1()
{
    String s1="abcd";
    System.out.println(resverse(s1));
    System.out.println(resverse1(s1));
    System.out.println(resverse2(s1));
}
```



## 接口、lambda表达式与内部类

- 匿名内部类中调用外部的变量，这个外部变量必须是final类型



## JAVA中为什么byte的取值范围是-128到+127？

**在学习Java基础语法的时候，初学者的我们可能都会有这么一个疑问为什么byte类型的取值范围为什么是[-128,127]而不是[-127,127]。01111111表示最大的数值：127，因为第一位是符号位，所以11111111应该是最小的数值：-127，不是这样才对？**

在解释这个问题之前我们需要了解几个概念：机器数、真值、原码、反码、补码

**机器数：**

一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1。

比如：十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。

**真值：** 
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

**原码：** 
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001 
[-1]原 = 1000 0001 
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111] 
即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.

**反码：** 
反码的表示方法是:正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

[+1] = [00000001]原 = [00000001]反 
[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

**补码：** 
补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补 
[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

**正数：** 
正数的反码和补码都与原码相同 
**负数：** 
负数的反码、补码与原码不同，负数的反码：原码中除去符号位，其他的数值位取反，0变1，1变0。负数的补码：反码+1

例如：



**解释：为什么byte类型的取值范围为-128~127？**

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

　　[+1] = [00000001]原 = [00000001]反 = [00000001]补

　　所以不需要过多解释. 但是对于负数:

　　[-1] = [10000001]原 = [11111110]反 = [11111111]补

　　可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

　　首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

　　于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

　　计算十进制的表达式: 1-1=0

　　1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

　　如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

　　为了解决原码做减法的问题, 出现了反码:

　　计算十进制的表达式: 1-1=0

　　1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

　　发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

　　于是补码的出现, 解决了0的符号以及两个编码的问题:

　　1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

　　(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

　　-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]。

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。



## 数值类型的大小及其原理

**byte**

范围：-128~127

解释：  一个byte由八个位组成，如00000000，其中，前7位表示数值，第8位是符号位（0为正，1为负）。这样+1就是00000001，-1就是10000001。最大的正数就是0 1111111，即2^0+2^1+……+2^6=127；最小的负数，同理，为1 1111111，即-127。

到这里应该是许多人不明白的地方，为什么负数会到-128。这不得不崇拜伟大的印度阿三们。

上述的描述会出现一个问题，就是0，会出现一个+0和一个-0。印度人他们规定-0为-128，这样就与计算机的补码（程序都是按补码运行的）完美的结合在一起。

以此类推，int，short，long都可以推出他们的取值范围。  



**short**

两个字节



**int**

四个字节





## 深入理解 char * , char ** , char a[ ] , char *a[]

#### 数组的本质

数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。

#### 指针

指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在32位平台下，指针默认为32位。

指针的指向

指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型。

int  * p ;//p 变量保存的地址所在内存单元中的数据类型为整型

float *q;// ........................................浮点型

不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。

### 字符数组

字面意思是数组，数组中的元素是字符。。确实，这就是它的本质意义。

char  str[10]; 

定义了一个有十个元素的数组，元素类型为字符。

C语言中定义一个变量时可以初始化。

char  str[10] = {"hello"};

当编译器遇到这句时，会把str数组中从第一个元素把hello\0 逐个填入。。

由于C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。

C语言中规定数组代表数组所在内存位置的首地址，也是 str[0]的地址，即str = &str[0];

 而printf("%s",str); 为什么用首地址就可以输出字符串。。

因为还有一个关键，在C语言中字符串常量的本质表示其实是一个地址，这是许多初学者比较难理解的问题。。。

​    举例：

​    char  *s ;

​    s = "China";

​    为什么可以把一个字符串赋给一个指针变量。。

​    这不是类型不一致吗？？？

​    这就是上面提到的关键 。。

​    C语言中编译器会给字符串常量分配地址，如果 "China", 存储在内存中的 0x3000 0x3001 0x3002 0x3003 0x3004 0x3005 .

​    s = "China" ，意识是什么，对了，地址。

​    其实真正的意义是 s ="China" = 0x3000;

​    看清楚了吧 ，你把China 看作是字符串，但是编译器把它看作是地址 0x3000，即字符串常量的本质表现是代表它的第一个字符的地址。。。。。。。。。。

​    s = 0x3000

​    这样写似乎更符合直观的意思。。。

​    搞清楚这个问题。。

​    那么 %s ，它的原理其实也是通过字符串首地址输出字符串，printf("%s ", s);   传给它的其实是s所保存的字符串的地址。。。

​    比如

​    \#include <stdio.h>  

​    int main()  

​    {  

​      char *s;  

​      s = "hello";  

​      printf("%p\n",s);  

​      return 0;  

​    }  

​    结果：

​    00422020

​    可以看到 s = 0x00422020 ，这也是"hello"的首地址

​    所以，printf("%s",0x00422020);也是等效的。。

​     

​    字符数组：

​    char  str[10] = "hello"；

​    前面已经说了，str = &str[0] ， 也等于 "hello"的首地址。。

​    所以printf("%s",str); 本质也是 printf("%s", 地址");

​    C语言中操作字符串是通过它在内存中的存储单元的首地址进行的，这是字符串的终极本质。。。

char *  与 char  a[ ];

   char  *s;

   char  a[ ] ;

   前面说到 a代表字符串的首地址，而s 这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，这个地址单元中的数据是一个字符，

   这也与 s 所指向的 char 一致。

   因此可以 s = a;

   但是不能 a = s;

   C语言中数组名可以复制给指针表示地址， 但是却不能赋给给数组名，它是一个常量类型，所以不能修改。。

   当然也可以这样:

​    char  a [ ] = "hello";  

​    char *s =a;  

​    for(int i= 0; i < strlen(a) ; i++)  

​          printf("%c", s[i]);  

​    或  printf("%c",*s++);

​    字符指针可以用 间接操作符 *取其内容，也可以用数组的下标形式 [ ]，数组名也可以用 *操作，因为它本身表示一个地址 。。

​    比如 printf("%c",*a);  将会打印出 'h'

​    char * 与 char a[ ] 的本质区别：

​    当定义 char a[10 ]  时，编译器会给数组分配十个单元，每个单元的数据类型为字符。。

​    定义 char *s 时，  这是个指针变量，只占四个字节，32位，用来保存一个地址。。

​    sizeof(a) = 10 ；

 

​    sizeof(s)  = ?

​    当然是4了，编译器分配4个字节32位的空间，这个空间中将要保存地址。。。

​    printf("%p",s);

​    这个表示 s 的单元中所保存的地址。。

​    printf("%p",&s);

​    这个表示变量本身所在内存单元地址。。。。，不要搞混了。。

​    用一句话来概括，就是 char *s 只是一个保存字符串首地址的指针变量， char a[] 是许多连续的内存单元，单元中的元素为char ，之所以用 char *能达到

​    char a[] 的效果，还是字符串的本质，地址，即给你一个字符串地址，便可以随心所欲的操所他。。但是，char* 和 char a[ ] 的本质属性是不一样的。。

#### char **  与char  *a[ ] 

  先看 char  *a[ ] ;

  由于[ ] 的优先级高于* 所以a先和 [ ]结合，他还是一个数组，数组中的元素才是char * ，前面讲到char * 是一个变量，保存的地址。。

  所以 char *a[ ] = {"China","French","America","German"}；

  同过这句可以看到， 数组中的元素是字符串，那么sizeof(a) 是多少呢，有人会想到是五个单词的占内存中的全部字节数 6+7+8+7 = 28；

  但是其实sizeof(a) = 16；

  为什么，前面已经说到， 字符串常量的本质是地址，a 数组中的元素为char * 指针，指针变量占四个字节，那么四个元素就是16个字节了

  看一下实例：

  \#include <stdio.h>  

  int main()  

  {  

​    char *a [] = {"China","French","America","German"};  

  　 printf("%p %p %p %p\n",a[0],a[1],a[2],a[3]);  

  　 return 0;  

  }  

 

  可以看到数组中的四个元素保存了四个内存地址，这四个地址中就代表了四个字符串的首地址，而不是字符串本身。。。

  因此sizeof(a)当然是16了。。

  注意这四个地址是不连续的，它是编译器为"China","French","America","German" 分配的内存空间的地址， 所以，四个地址没有关联。

  \#include <stdio.h>  

  int main()  

  {  

​    char *a [ ] = {"China","French","America","German"};  

​    printf("%p %p %p %p\n",a[0],a[1],a[2],a[3]); //数组元素中保存的地址  

​    printf("%p %p %p %p\n",&a[0],&a[1],&a[2],&a[3]);//数组元素单元本身的地址  

​    return 0;  

  }  

  可以看到 0012FF38 0012FF3C 0012FF40 0012FF44,这四个是元素单元所在的地址，每个地址相差四个字节，这是由于每个元素是一个指针变量占四个字节。。。

  char **s;

  char **为二级指针， s保存一级指针 char *的地址，关于二级指针就在这里不详细讨论了 ，简单的说一下二级指针的易错点。  

  举例：

  char *a[] = {"China","French","America","German"};  

  char **s = a;  

  为什么能把 a赋给s,因为数组名a代表数组元素内存单元的首地址，即 a = &a[0] = 0012FF38;

  而 0x12FF38即 a[0]中保存的又是 00422FB8 ,这个地址， 00422FB8为字符串"China"的首地址。

  *s = 00422FB8 = "China";

  这样便可以通过s 操作 a 中的数据

  printf("%s",*s);  

  printf("%s",a[0]);  

  printf("%s",*a);  

  都是一样的。。。

  但还是要注意，不能a = s，前面已经说到，a 是一个常量。。

  再看一个易错的点：

  char **s = "hello world";

  这样是错误的，

  因为  s 的类型是 char **  而 "hello world "的类型是 char *

  虽然都是地址， 但是指向的类型不一样，因此，不能这样用。，从其本质来分析，"hello world",代表一个地址，比如0x003001,这个地址中的内容是 'h',为 char 型，而 s 也保存一个地址 ，这个地址中的内容(*s) 是char *　，是一个指针类型，　所以两者类型是不一样的。　。。

　如果是这样呢？

 char  **s;  

 *s = "hello world";  

 貌似是合理的，编译也没有问题，但是 printf("%s",*s),就会崩溃

 why??

 咱来慢慢推敲一下。。

 printf("%s",*s); 时，首先得有s 保存的地址，再在这个地址中找到 char *  的地址，即*s;

 举例：

 s = 0x1000;  

 在0x1000所在的内存单元中保存了"hello world"的地址 0x003001 ， *s = 0x003001;

这样printf("%s",*s);

这样会先找到 0x1000,然后找到0x003001;

如果直接 char  **s;

*s = "hello world";  

s 变量中保存的是一个无效随机不可用的地址， 谁也不知道它指向哪里。。。。，*s 操作会崩溃。。

所以用 char **s 时，要给它分配一个内存地址。

char  **s ;  

s = (char **) malloc(sizeof(char**));  

*s =  "hello world"; 

这样 s 给分配了了一个可用的地址，比如 s = 0x412f;

然后在 0x412f所在的内存中的位置，保存 "hello world"的值。。

再如：

   

\#include  <stdio.h>  

void  buf( char **s)  

 {  

​        *s = "message";  

 }  

 int main()  

 {  

​     char *s ;  

​     buf(&s);  

​     printf("%s\n",s);  

 }  

二级指针的简单用法。。。。，说白了，二级指针保存的是一级指针的地址，它的类型是指针变量，而一级指针保存的是指向数据所在的内存单元的地址，虽然都是地址，但是类型是不一样的。。。

最后说明，sizoof(指针)的大小更具电脑操作系统而定，一般32位操作系统所占用的内存大小是4，64位操作系统指针的大小是8。

这篇博客是转转的

 char  **s;  
 *s = "hello world"; 
在我的ubuntu上打印 printf("%s",*s),没有崩溃





## &&和&的区别

**&&**

表示逻辑与的意思，即为and。当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。

比如 12&&23的结果就是1，12&&-1 的结果是1，123&&0的结果就是0

 

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException

 

**&**

表示按位与。

&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。

二进制与运算规则:1&1=1  1&0=0  0&0=0

15&127为什么等于15啊？ 

15二进制： （0000 1111）

127二进制： （1111 1111）

按位与自然就是（0000 1111）＝15



**||**

表示逻辑或

 逻辑或，是逻辑运算符，符号是“||”(在PASCAL中为"or")。 “逻辑或”相当于生活中的“或者”，当两个条件中有任一个条件满足，“逻辑或”的运算结果就为“真”

12||1 =1  12||0 =1 0||0 =0

 

**|**

表示按位或

按位或运算 按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位（也就是最后一位）相或。只要对应的二个二进位有一个为1时，结果位就为1。

128：     （0001 0000 0000）

127：     （0000 1111 1111） （高位用0补齐）

按位或就是（0001 1111 1111）＝255