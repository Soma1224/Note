# 数据结构

## 递归

必要的两个条件：

- 递归出口
- 递归表达式

实例：

- 求F数列的第n项和

![Snipaste_2018-10-19_15-09-05](.\picture\Snipaste_2018-10-19_15-09-05.png)



- 求从1加到n的所有数的和

![Snipaste_2018-10-19_15-16-44](.\picture\Snipaste_2018-10-19_15-16-44.png)



- 运用递归求数组的所有元素的和

![Snipaste_2018-10-19_14-30-40](.\picture\Snipaste_2018-10-19_14-30-40.png)

- 求一个数组里面前n项的最大值

![Snipaste_2018-10-19_14-46-33](.\picture\Snipaste_2018-10-19_14-46-33.png)



## 线性表

### 链表

==链表的header是在0位置之前的==

![1539743201035](.\picture\1)



## 受限线性表

### 栈（先进后出）

- 栈的顺序存储

==利用一组连续的存储单元依次存放自栈底到栈顶的数据元素==，栈顶需要在数组的最右端，这样的话数据就不需要频繁地移动

- 栈的链式存储

非连续的内存空间

### 队列（先进先出）

- 队列的顺序存储

连续的内存空间

- 队列的链式存储

非连续的内存空间











## 树

### 结构特点

- 非线性结构，有一个直接前驱，但可能有多个直接后继
- 树的定义具有递归性，树中还有树
- 树可以为空，即结点个数为0

### 分类

- 满二叉树（国内定义）

一棵深度为k且有$2^{k+1}$个结点的二叉树

- 完全二叉树

除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边若干个结点

### 二叉树的遍历

- 遍历方法 ==牢记一种约定，对于每一个结点的查看都是“先左后右”==
  - 前序遍历
  - 中序遍历
  - 后序遍历

- 二叉树的递归遍历
- 二叉树的非递归遍历



## 动态规划

- 选与不选的问题(对每个元素而言)
- 题目一： 如何在一个数组中选择不相邻的数子使得这些数字的和最大

![1540863514266](.\picture\%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540863514266.png)

- 题目二：给定一个数组和一个数字，判断这个数组中的是否有元素的和等于给定的数字，有返回true，没有返回false
  - 可以转化为求子集Subset的问题Subset(arr[i],s)，其中i代表第几个数字，s代表所求的那个和，这里表示当为第i个数字的时候，本次方案如何分配



![动态规划题目二](.\picture\动态规划题目二.jpg)





解析：

- 递归式



- 出口的寻找
  - 当Subset(arr[i],s)中s等于0的时候，返回true（不管i等于多少，前面的已经不用看了，已近得到结果）	

  - 当Subset(arr[i],s)中的i等于0的时候，表示数组进行到第一位了，此时必须arr[i]==s才行		

  - 当Subset(arr[i],s)中的arr[i]>s的时候，我们这时候就不能选择arr[i]，就是考虑不选的情况，也就是Subset(arr[i-1],s)

    ​	

